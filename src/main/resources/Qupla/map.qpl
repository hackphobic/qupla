// implements a simple key/value storage
// needs to be wrapped in an entity function and accessed through
// sending effects to work correctly

template map<K, V>
{
  type Traversal {
    cmd [Trit]
    key [K]
    value [V]
  }

  func V map<K, V> (Trit cmd, K key, V value) {
    param = Traversal {
      cmd = cmd
      key = key
      value = value
    }
    return traverse<K, V>(param)
  }

  func V traverse<K, V> (Traversal param) {
    // note that for readability we should probably split this function
    // into two functions, one for the case where we call leaf() and one
    // for the case where we do the traverse() and determine nextParam,
    // but that would effectively double the length of the recursive call
    // path, so for storage efficiency reasons we keep them together as one

    keyZero = isZero[sign<K>(param.key)]

    // note that once our optimization for conditional expressions
    // back-pushes nullify() we will not need the next line any more
    altParam = not[keyZero] ? param : null

    keyTrit = altParam.key[0]
    nextParam = Traversal {
      cmd = altParam.cmd
      key = lshift<K>(altParam.key)
      value = altParam.value
    }

    keyTritIs1  = isOne[keyTrit]
    keyTritIs0 = isZero[keyTrit]
    return keyZero ? leaf<K, V>(param) :
             keyTritIs1 ? traverse<K, V>(nextParam) :
               keyTritIs0 ? traverse<K, V>(nextParam) :
                 traverse<K, V>(nextParam)
  }

  func V leaf<K, V> (Traversal param) {
    state V value

    oldValue = value

    cmd = param.cmd
    get = isZero[cmd]
    set = isOne[cmd]
    value = get ? oldValue : set ? param.value : 0

    return oldValue
  }
}
