// implements a simple key/value storage
// needs to be wrapped in an entity function and accessed through
// sending effects to work correctly

template map<K, V>
{
  type Traversal {
    cmd [Trit]
    key [K]
    value [V]
  }

  func V map<K, V> (Trit cmd, K key, V value) {
    param = Traversal {
      cmd = cmd
      key = key
      value = value
    }
    return traverse<K, V>(param)
  }

  func V traverse<K, V> (Traversal param) {
    // note that for readability we should probably split this function
    // into two functions, one for the case where we call leaf() and one
    // for the case where we do the traverse() and determine nextParam,
    // but that would effectively double the length of the recursive call
    // path, so for storage efficiency reasons we keep them together as one

    keyZero = isZero[sign<K>(param.key)]

    keyTrit = param.key[0]
    return keyZero ? leaf<K, V>(param) :
           isOne [keyTrit] ? traverse<K, V>(traverseNext<K, V>(keyZero, param)) :
           isZero[keyTrit] ? traverse<K, V>(traverseNext<K, V>(keyZero, param)) :
           isMin [keyTrit] ? traverse<K, V>(traverseNext<K, V>(keyZero, param)) : null
  }

  func Traversal traverseNext<K, V> (Bool keyZero, Traversal param) {
    return not[keyZero] ? Traversal {
      cmd = param.cmd
      key = lshift<K>(param.key)
      value = param.value
    } : null
  }

  func V leaf<K, V> (Traversal param) {
    state V value

    oldValue = value

    cmd = param.cmd
    value = isZero[cmd] ? oldValue : isOne[cmd] ? param.value : isMin[cmd] ? 0 : null

    return oldValue
  }
}
