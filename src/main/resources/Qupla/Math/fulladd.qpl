// LUT logic: return the sum of two trits plus a carry as a single trit plus a new carry
//            return (trit1 + trit2 + carry), newcarry(trit1 + trit2 + carry)
lut fullAdd {
  -,-,- = 0,-
  -,-,0 = 1,-
  -,-,1 = -,0
  -,0,- = 1,-
  -,0,0 = -,0
  -,0,1 = 0,0
  -,1,- = -,0
  -,1,0 = 0,0
  -,1,1 = 1,0
  0,-,- = 1,-
  0,-,0 = -,0
  0,-,1 = 0,0
  0,0,- = -,0
  0,0,0 = 0,0
  0,0,1 = 1,0
  0,1,- = 0,0
  0,1,0 = 1,0
  0,1,1 = -,1
  1,-,- = -,0
  1,-,0 = 0,0
  1,-,1 = 1,0
  1,0,- = 0,0
  1,0,0 = 1,0
  1,0,1 = -,1
  1,1,- = 1,0
  1,1,0 = -,1
  1,1,1 = 0,1
}


// returns lhs + rhs + carry

func TritCarry fullAdd<Trit> (Trit lhs, Trit rhs, Carry carry) {
  return fullAdd[lhs, rhs, carry]
}

template fullAdd3<T> = A + B + C {
  type A [T / 3]
  type B [T / 3]
  type C [T / 3]
  type TCarry {
    value [T]
    carry [Carry]
  }

  func TCarry fullAdd<T> (T lhs, T rhs, Carry carry) {
    add0 = fullAdd<A>(lhs[0 : A], rhs[0 : A], carry)
    add1 = fullAdd<B>(lhs[A : B], rhs[A : B], add0.carry)
    add2 = fullAdd<C>(lhs[A + B : C], rhs[A + B : C], add1.carry)
    return add0.value & add1.value & add2
  }
}

template fullAdd<T> {
  type A [T - T / 2]
  type B [T - A]
  type TCarry {
    value [T]
    carry [Carry]
  }

  func TCarry fullAdd<T> (T lhs, T rhs, Carry carry) {
    add0 = fullAdd<A>(lhs[0 : A], rhs[0 : A], carry)
    add1 = fullAdd<B>(lhs[A : B], rhs[A : B], add0.carry)
    return add0.value & add1
  }
}
